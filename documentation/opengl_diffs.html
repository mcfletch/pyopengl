<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
    <title>PyOpenGL for OpenGL Programmers</title>
    <link rel="stylesheet" type="text/css" href="tutorial.css">
    <meta name="author" content="Mike C. Fletcher">
  </head>
  <body>
    <h1>PyOpenGL for OpenGL Programmers<br>
    </h1>
    <p class="introduction">This document describes those features of
      PyOpenGL which are likely to be unfamiliar to OpenGL programmers.
      It also explains various features of PyOpenGL which are not covered in
      general OpenGL documentation.<br>
    </p>
    <h2>Speed Concerns</h2>
    <p>PyOpenGL 3.x is far slower than PyOpenGL 2.x,
      and PyOpenGL 2.x was not fast. Out of the box PyOpenGL 3.x is
      configured to be as helpful and robust as possible, both traits which
      make the system much slower than it could be. PyOpenGL is now
      implemented using ctypes, rather than SWIG, the flexibility of ctypes
      has a significant cost in terms of performance. PyOpenGL 3.x is
      also far more flexible with regard to data-types, that flexibility has
      a noticeable performance cost. Throughout this document you will
      see descriptions for how to trade off flexibility, helpfulness and
      robustness in order to claw back speed.</p>
    <p>If you are attempting to
      do per-vertex operations (e.g. glColor, glNormal, glVertex) then you
      will find that PyOpenGL 3.x is ridiculously slow. Luckily, all of
      those features are now deprecated. For array-based geometry where
      the arrays are large and in native-format-compatible formats,
      PyOpenGL's overhead tends to be amortized over the size of the arrays
      being processed.</p>
    <h2>Method Signatures vs. C OpenGL<br>
    </h2>
    <p>Most of the functions which appear in PyOpenGL 3 are identical in
      calling method and functionality to that of the appropriate C
      specification. There are a few exceptions because of the
      differences between C and Python. Most of these exceptions are due to
      the difference between C and Python in the way that they access
      arrays. For example, a C function like this:</p>
    <pre>void foo(int count, const int *args);</pre>
    <p>will normally have the Python binding:</p>
    <pre>foo(args) -&gt; None</pre>
    <p>Also C functions which write array data to a function argument like:</p>
    <pre>void bar(int args[4]);</pre>
    <p>will normally have the Python binding:</p>
    <pre>bar() -&gt; args[]</pre>
    <p>The following sections will document changes other than simple
      changes like the above examples.<br>
    </p>
    <h2>Errors raise Exceptions</h2>
    <p>PyOpenGL generally uses "strict" OpenGL operation, which is closer to
      the operation of Python itself, i.e. errors are raised as exceptions,
      rather than requiring the user to check return values and/or call
      glCheckError manually.</p>
    <p>You
      can disable PyOpenGL's error checking by setting a module-level flag in
      the OpenGL package before importing any of the sub-modules, like so:</p>
    <pre>import OpenGL<br>OpenGL.ERROR_CHECKING = False<br>from OpenGL.GL import *<br>from OpenGL.GLU import *<br>...</pre>
    <p>This will tend to cause a huge speed increase in your code, as the
      number of OpenGL calls issued will roughly halve compared to the
      error-checking version of the same script. You will normally want
      to develop with error-checking on and only switch it off for
      production/release code.&nbsp; Note, however, that most PyOpenGL code
      (including helper code in PyOpenGL itself) is written with the assumption
      that errors raise exceptions, so you will have to review all code you use
      to be sure you are calling glGetError where appropriate.</p>
    <p>The exceptions normally raised by PyOpenGL are:<br>
    </p>
    <ul>
      <li>GL.GLerror by all modules except WGL</li>
      <li>GLU.GLUerror by some GLU functions. Note that GLU can also throw
        GL.GLerror</li>
      <li>WindowsError/SystemError by WGL</li>
      <li>General TypeError/ValueError errors for e.g. wrong-data-type problems</li>
    </ul>
    <p>GL.GLerror is a subclass of GL.Error and has a large amount of extra
      information regarding the call wrapping process:</p>
    <ul>
      <li>err -- OpenGL error code</li>
      <li>result -- OpenGL result-code for the operation</li>
      <li>baseOperation -- the base OpenGL function being called</li>
      <li>pyArgs -- the set of top-level arguments passed to the function</li>
      <li>cArgs -- the set of Python-level objects expanded from pyArgs</li>
      <li>cArguments -- the set of C-level objects converted from cArgs</li>
      <li>description -- textual OpenGL description of the error (normally
        pretty terse, useful primarily to look at the documentation)</li>
    </ul>
    <h2>Logging</h2>
    <p>By default, PyOpenGL will log errors to the Python
      logging module. You can disable this by setting a flag before
      importing the OpenGL sub-modules:</p>
    <pre>import OpenGL<br>OpenGL.ERROR_LOGGING = False<br>from OpenGL.GL import *<br>...</pre>
    <p>which will provide a performance improvement for non-development code.</p>
    <p>Conversely,
      if you are finding that your code is crashing and you need to trace
      through the operation of PyOpenGL then it is possible to instruct
      PyOpenGL to trace the calls to OpenGL to the logging module:</p>
    <pre>import OpenGL<br>OpenGL.FULL_LOGGING = True<br>from OpenGL.GL import *<br>...</pre>
    <p>this is extremely slow, but often useful during the debugging process.</p>
    <h2>Wrapped Operations</h2>
    <p>Wrapped Python arguments may go through a number of possible wrapper
      operations in order to produce a final call from the Python
      argument-set:</p>
    <ul>
      <li>takes a set of args and passes a set of converters over them to
        convert them to acceptable object types (pyArgs)</li>
      <li>runs
        a set of cConverters over pyArgs to produce a set of cArgs,
        representing the Pythonic objects which map 1:1 to the C arguments
        (cArgs), this will often expand arguments from a single Python argument
        to mulitple C argument objects</li>
      <li>runs a set of cResolvers over cArgs to produce a set of final
        ctypes-compatible arguments (cArguments)</li>
      <li>runs
        a set of storeValues converters to save any temporary objects which
        need to remain in-memory to prevent memory-access failures for later
        calls (e.g. references to pointers require that the object holding the
        memory remain in-memory)</li>
      <li>runs a function to choose what value to return from the function</li>
    </ul>
    <p>These
      operations are implemented by the OpenGL.wrapper.Wrapper class, which
      is the focus of most of theOpenGL_accelerate module's optimizations
      (for obvious reasons).</p>
    <h2>Array Handling</h2>
    <p>PyOpenGL 3.x supports a significant range of array-compatible data-types,
      among the default plug-ins are:</p>
    <ul>
      <li>numpy arrays</li>
      <li>Python strings (byte-strings)</li>
      <li>numbers (acting as pointers-to-single-value arrays)</li>
      <li>ctypes arrays</li>
      <li>ctypes parameters</li>
      <li>ctypes pointers</li>
      <li>lists/tuples</li>
      <li>vertex buffer objects</li>
    </ul>
    <p>when
      a PyOpenGL 3.x entry point requires an "array" data-type (or a void*
      data-type), it will use the PyOpenGL FormatHandler plugins
      (OpenGL.arrays.formathandler) to decide how to convert the array to a
      format compatible with the low-level OpenGL APIs.</p>
    <p>Certain
      format-types may allow for use as array types while not actually
      containing a compatible copy of the data. Python lists, tuples
      and numbers all require the creation of a temporary variable to hold
      their data. As such you generally should not use them for
      performance-critical operations. Similarly, if you pass a numpy
      array with an incompatible data-type the wrapper may have to copy the
      data in order to pass it into the C-level functions. For numpy
      arrays, where the behavior is fast enough that you might not realize
      it, but can negatively impact your performance, you can prevent this
      behaviour by setting a flag in the OpenGL package before importing any
      of the OpenGL modules:</p>
    <pre>import OpenGL<br>OpenGL.ERROR_ON_COPY = True<br>from OpenGL.GL import *</pre>
    <p>which will cause the numpy format handler to raise errors if it finds
      itself copying an array to another data-type.</p>
    <p class="technical">Keep in mind that with OpenGL 3.1 it will become
      required that all non-index arrays be managed as Vertex Buffer Objects.</p>
    <h3>Type-Specialized Array Functions</h3>
    <p>Each call which sets an array pointer, such as glVertexPointer, may
      have many variants. First there will a function which is identical that
      of the specification. For the pointer argument one should pass a string.
      Also note that the stride values are used.</p>
    <p>Next there will a set of functions named:</p>
    <pre>glXPointer{ub|b|us|s|ui|i|f|d}</pre>
    <p>These will usually take as a single argument a multidimensional
      array of values. The type argument is controlled by the suffix of the
      function (ub is unsigned byte, b is byte, f is float, d is double etc.)
      Most other arguments are derived from the dimensions of the array.</p>
    <p>So for glColorPointer we have:</p>
    <pre>glColorPointer(size, type, stride, pointer) -&gt; None<br>glColorPointerub(pointer[][]) -&gt; None<br>glColorPointerb(pointer[][]) -&gt; None<br>glColorPointerus(pointer[][]) -&gt; None<br>glColorPointers(pointer[][]) -&gt; None<br>glColorPointerui(pointer[][]) -&gt; None<br>glColorPointeri(pointer[][]) -&gt; None<br>glColorPointerf(pointer[][]) -&gt; None<br>glColorPointerd(pointer[][]) -&gt; None</pre>
    <p>This same decoration strategy is used for other array functions
      besides glXPointer.</p>
    <p>For instance, glDrawElements has the Python binding:</p>
    <pre>glDrawElements(mode, count, type, indices) -&gt; None</pre>
    <p>where indices is expected to be a string. There are also the
      decorated bindings:</p>
    <pre>glDrawElementsub(mode, indices[]) -&gt; None<br>glDrawElementsus(mode, indices[]) -&gt; None<br>glDrawElementsui(mode, indices[]) -&gt; None</pre>
    <p>where "indices" is now a single dimensional array.</p>
    <p>When calling a glColorPointer, glVertexPointer, etc. Python needs to
      allocate memory to store the values that OpenGL needs. This memory is
      reference counted and takes into account function calls like
      glPushClientAttrib and glPopClientAttrib. To force this memory to be
      released one just need to make a call glColorPointerub(None).</p>
    <p>Currently glPushClientAttrib will always set the
      GL_CLIENT_VERTEX_ARRAY_BIT flag as glPopClientAttrib has no way of
      knowing that flag was set and the state of the flag is needed to know
      whether or not to decrement the pointer locks on the allocated memory.</p>
    <p>This may change in the future. That said, surrounding array use
      glPushClientAttrib/glPopClientAttrib is a good way to force the release
      of any allocated memory, but make sure that all calls to glXPointer,
      etc. are within the ClientAttrib block if you chose to use this scheme.</p>
    <p class="technical">Note that since all the memory allocation is
      automatic there is no need for glGetPointerv function, so it is excluded.</p>
    <p class="technical">Note that the function glInterleavedArrays is also
      present, but it does not have the variants that the others do (i.e., no
      glInterleavedArraysf). glInterleavedArrays has been unofficially
      deprecated for a long time, and is officially deprecated as of OpenGL
      3.x</p>
    <p class="technical">Note that for performance you may wish to use
      the "raw" version of array-handling functions, as these often have less
      processing applied than the "raw" version.
    </p>
    <h2>Image Routines</h2>
    <p>glDrawPixels and the other image/texturing functions have much the
      same decoration scheme as the array functions. For glDrawPixels there is
      the standard function which expects a string as the pixel data:<br>
    </p>
    <pre>glDrawPixels(width, height, format, type, pixels) -&gt; None</pre>
    <p>This function will respect the parameters set by glPixelStore{i|f}.</p>
    <p>There is also a collection of variants which take a multidimensional
      array as the data source and set glPixelStore{i|f} automatically. For
      example:<br>
    </p>
    <pre>glDrawPixelsub(format, pixels) -&gt; None</pre>
    <p>Notice that width and height are inferred from the pixel data and
      the type is GLubyte.</p>
    <p>PyOpenGL
      sets up "normal" pixel-transfer mode when using imaging APIs, as almost
      all Python image-aware modules/extensions assume, for instance, tightly
      packed data-structures and would potentially cause access errors when
      operating in standard OpenGL mode.<br>
    </p>
    <h2>Extensions and Conditional Functionality<br>
    </h2>
    <p>PyOpenGL has support for most OpenGL extensions. Extensions are
      available as "normal" function pointers by importing the constructed
      package name for the extension, for instance:</p>
    <pre>from OpenGL.GL.ARB.vertex_buffer_object import *<br>buffer = glGenBuffersARB(1)</pre>
    <p>there
      is no need to call initialization functions or the like for the
      extension module. You can, if you like, call the "init" function for
      the extension to retrieve a boolean indicating whether the local
      machine supports a given extension, like so:</p>
    <pre>if glInitVertexBufferObjectARB():<br>	...</pre>
    <p>However, it is normally clearer to test for the boolean truth of the
      entry points you wish to use:</p>
    <pre>if (glGenBuffersARB):<br>	buffers = glGenBuffersARB( 1 )</pre>
    <p>There
      are often a number of entry points which implement the same API, for
      which you would like to use whichever implementation is available
      (likely with some preference in order). The OpenGL.extensions module
      provides an easy mechanism to support this:</p>
    <pre>from OpenGL.extensions import alternate<br>glCreateProgram = alternate( 'glCreateProgram', glCreateProgram, glCreateProgramObjectARB)<br>glCreateProgram = alternate( glCreateProgram, glCreateProgramObjectARB)</pre>
    <p>If
      the first element is a string it will be used as the name of the
      alternate object, otherwise the name is taken from the first argument.</p>
    <h2>Selection and Feedback Buffers<br>
    </h2>
    <p class="technical">Note that both selection and feedback buffers are
      deprecated in OpenGL 3.x. You should be replacing
      selection-buffer usage with either "unique color" selection rendering
      or mathematical generated selection operations.</p>
    <p>Normally in OpenGL to use a selection buffer one would do the
      following:</p>
    <pre>GLuint buffer[SIZE];<br>glSelectBuffer(SIZE, buffer);<br>glRenderMode(GL_SELECT);<br>/* draw some stuff */<br>GLint count = glRenderMode(GL_RENDER);<br>/* parse the selection buffer */</pre>
    <p>In Python this accomplished like this:</p>
    <pre>glSelectBuffer(SIZE) # allocate a selection buffer of SIZE elements<br>glRenderMode(GL_SELECT)<br># draw some stuff<br>buffer = glRenderMode(GL_RENDER)<br>for hit_record in buffer:<br>&nbsp;&nbsp;&nbsp; min_depth, max_depth, names = hit_record<br>&nbsp;&nbsp;&nbsp; # do something with the record</pre>
    <p>Feedback buffers are used in the same way except that each item in
      the buffer is tuple (token, value), where value is either a passthrough
      token or a list of vertices.<br>
    </p>
    <p class="technical">Note that if glRenderMode returns a buffer then it
      also <strong>resets OpenGL's pointer</strong> for the corresponding
      buffer. This means that the buffer returned by glRenderMode is
      independent of future calls to glRenderMode, i.e. it will not be
      overwritten by any such future calls. This makes the returned buffer
      somewhat thread-safe. It also means that <strong>every call to
        glRenderMode(GL_SELECT | GL_FEEDBACK)</strong> needs to <strong>preceded
by
        a call to glSelectBuffer or glFeedbackBuffer</strong> first, i.e. the
      following code <strong>will not work</strong>:</p>
    <pre>### THIS DOESN'T WORK!!!<br>glSelectBuffer(SIZE) # allocate a selection buffer of SIZE elements<br>glRenderMode(GL_SELECT)<br># draw some stuff<br>buffer = glRenderMode(GL_RENDER)<br># do another selection<br>glRenderMode(GL_SELECT)<br># draw some stuff<br>buffer = glRenderMode(GL_RENDER)</pre>
    <p class="technical">Instead one must do:<br>
    </p>
    <pre>glSelectBuffer(SIZE) # allocate a selection buffer of SIZE elements<br>glRenderMode(GL_SELECT)<br># draw some stuff<br>buffer = glRenderMode(GL_RENDER)<br># do another selection<br>glSelectBuffer(SIZE) allocate a new selection buffer<br>glRenderMode(GL_SELECT)<br># draw some stuff<br>buffer = glRenderMode(GL_RENDER)</pre>
    <h2>Function Aliases</h2>
    <p>PyOpenGL has historically provided a number of aliases for
      functions.&nbsp; For backwards compatibility, these aliases continue to
      be provided:<br>
    </p>
    <ul>
      <li>glGetBooleanv aliases</li>
      <ul>
        <li>glGetBoolean</li>
      </ul>
      <li>glGetDoublev aliases</li>
      <ul>
        <li>glGetDouble</li>
      </ul>
      <li>glGetIntegerv aliases</li>
      <ul>
        <li>glGetInteger</li>
      </ul>
      <li>glColord aliases</li>
      <ul>
        <li>glColor</li>
      </ul>
      <ul>
        <li>glColor3</li>
      </ul>
      <ul>
        <li>glColor4</li>
      </ul>
      <li>glEvalCoordd aliases</li>
      <ul>
        <li>glEvalCoord</li>
      </ul>
      <ul>
        <li>glEvalCoord1</li>
      </ul>
      <ul>
        <li>glEvalCoord2</li>
      </ul>
      <li>glFogfv aliases</li>
      <ul>
        <li>glFog</li>
      </ul>
      <li>glIndexd aliases</li>
      <ul>
        <li>glIndex</li>
      </ul>
      <li>glLightfv aliases</li>
      <ul>
        <li>glLight</li>
      </ul>
      <li>glLightModelfv aliases</li>
      <ul>
        <li>glLightModel</li>
      </ul>
      <li>glMaterialfv aliases</li>
      <ul>
        <li>glMaterial</li>
      </ul>
      <li>glNormald aliases</li>
      <ul>
        <li>glNormal</li>
      </ul>
      <ul>
        <li>glNormal3</li>
      </ul>
      <ul>
        <li>glNormal4</li>
      </ul>
      <li>glRasterPosd aliases</li>
      <ul>
        <li>glRasterPos</li>
      </ul>
      <ul>
        <li>glRasterPos2</li>
      </ul>
      <ul>
        <li>glRasterPos3</li>
        <li>glRasterPos4</li>
      </ul>
      <li>glRotated aliases</li>
      <ul>
        <li>glRotate</li>
      </ul>
      <li>glScaled aliases</li>
      <ul>
        <li>glScale</li>
      </ul>
      <li>glTexCoordd aliases</li>
      <ul>
        <li>glTexCoord</li>
        <li>glTexCoord1</li>
        <li>glTexCoord2</li>
        <li>glTexCoord3</li>
        <li>glTexCoord4</li>
      </ul>
      <li>glTexGendv aliases</li>
      <ul>
        <li>glTexGen</li>
      </ul>
      <li>glTexParameterfv aliases</li>
      <ul>
        <li>glTexParameter</li>
      </ul>
      <li>glTranslated aliases</li>
      <ul>
        <li>glTranslate</li>
      </ul>
      <li>glVertexd aliases</li>
      <ul>
        <li>glVertex</li>
      </ul>
    </ul>
    <p class="footer"><a href="index.html"><img src="../images/doc_logo_icon.gif"
          title="" alt="Documentation" style="border: 0px solid ; width: 32px; height: 32px;"
          align="middle"></a>&nbsp;<a href="http://pyopengl.sourceforge.net/"><img
          title="" alt="PyOpenGL" src="../images/icon2.jpg" style="border: 0px solid ; width: 32px; height: 32px;"
          align="middle"></a> A
      SourceForge Open-Source project: <a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=5988&amp;type=1"
          style="border: 0px solid ; width: 88px; height: 31px;" alt="SourceForge"
          title="" align="middle"></a></p>
  </body>
</html>
