<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
<title>Shader-based Rendering: First steps</title>
    <link href="./tutorial.css" type="text/css" rel="stylesheet" />
</head>
<body>
<table width="100%"><thead>
	<tr>
		<td width="8em;"></td><th align="center"><a href="index.html">OpenGLContext Python tutorials</a></th><td width="8em;"></td>
	</tr>
	<tr>
	<td><a href="index.html">Index</a></td>
	<td align="center">Shader-based Rendering: First steps</td>
	<td align="right"><a href="shader_2.xhtml">Next</a></td>
	</tr>
</thead></table>
	<div class="code-sample">#! /usr/bin/env python
</div>
	<div class="commentary">
	<h1 class="title">Shader-based Rendering: First steps</h1>
	<div class="paragraph">
	<img src="shader_1.py-screen-0001.png" alt="Screenshot" class="" />
</div>
	<div class="paragraph">This tutorial introduces modern OpenGL mechanisms for rendering 
3D geometry via the GL Shading Language (GLSL).  Although we will 
use a few legacy OpenGL features for simplicity in early tutorials,
later tutorials will eliminate these entry points to produce 
legacy-free code.</div>
	<div class="paragraph">We assume you know:</div>
	<ul class="">
	<li class="">General programming (with Python)</li>
	<li class="">Some highschool level math</li>
</ul>
	<div class="paragraph">We'll learn:</div>
	<ul class="">
	<li class="">What a vertex shader *must* do in GLSL.</li>
	<li class="">What a fragment shader *must* do.</li>
	<li class="">What a VBO object looks like.</li>
	<li class="">How to activate and deactivate shaders and VBOs.</li>
	<li class="">How to render simple geometry.</li>
</ul>
	<div class="paragraph">First we do our imports, the 
	<a href="http://pyopengl.sourceforge.net/context" class="">OpenGLContext</a>
	 testingcontext allows
for the use of Pygame, wxPython, or GLUT GUI systems with the same 
code.  These imports retrieve an appropriate context for this 
machine.
</div>
</div>
	<div class="code-sample">from OpenGLContext import testingcontext
BaseContext, MainFunction = testingcontext.getInteractive()
</div>
	<div class="commentary">
	<div class="paragraph">Now we import the PyOpenGL functionality we'll be using.</div>
	<div class="paragraph">OpenGL.GL contains the standard OpenGL functions that you can 
read about in the PyOpenGL man pages.
</div>
</div>
	<div class="code-sample">from OpenGL.GL import *
</div>
	<div class="commentary">
	<div class="paragraph">The OpenGL.arrays.vbo.VBO class is a convenience wrapper 
which makes it easier to use Vertex Buffer Objects from within 
PyOpenGL.  It takes care of determining which implementation 
to use, the creation of offset objects, and even basic slice-based 
updating of the content in the VBO.</div>
</div>
	<div class="code-sample">from OpenGL.arrays import vbo
</div>
	<div class="commentary">
	<div class="paragraph">OpenGLContext.arrays is just an abstraction point which imports 
either Numpy (preferred) or the older Numeric library 
with a number of compatability functions to make Numeric look like 
the newer Numpy module.</div>
</div>
	<div class="code-sample">from OpenGLContext.arrays import *
</div>
	<div class="commentary">
	<div class="paragraph">OpenGL.GL.shaders is a convenience library for accessing the 
shader functionality.</div>
</div>
	<div class="code-sample">from OpenGL.GL.shaders import *
</div>
	<div class="commentary">
	<div class="paragraph">OpenGLContext contexts are all sub-classes of Context, with 
various mix-ins providing support for different windowing classes,
different interaction mechanisms and the like.  BaseContext here 
is the TestingContext we imported above.</div>
</div>
	<div class="code-sample">class TestContext( BaseContext ):
	"""Creates a simple vertex shader..."""
</div>
	<div class="commentary">
	<div class="paragraph">The OnInit method is called *after* there is a valid
	OpenGL rendering Context.  You must be very careful not 
	to call (most) OpenGL entry points until the OpenGL context 
	has been created (failure to observe this will often cause 
	segfaults or other extreme behaviour).
</div>
</div>
	<div class="code-sample">	def OnInit( self ):
</div>
	<div class="commentary">
	<div class="paragraph">The compileProgram function is a testing/convenience 
		function which performs a number of base operations using 
		the OpenGL.GL.shaders convenience functions which abstract 
		away the various shader implementations available under 
		OpenGL.  (GLSL Shaders started as extensions and later 
		became part of Core OpenGL, which is the normal way that 
		OpenGL is improved/extended).</div>
	<div class="paragraph">compileProgram assumes that you are attempting to compile 
a single vertex shader and a single fragment shader. There
are (uncommon) other types of shaders (including geometry 
shaders, which are comparatively very new).</div>
	<div class="paragraph">Our first shader is the VERTEX_SHADER, which must calculate
a vertex position for each vertex which is to be generated.
Normally this is one vertex for each vertex we pass into the 
GL, but with geometry shaders and the like more vertices could 
be created.</div>
	<div class="paragraph">A vertex shader only needs to do one thing, which is to 
generate a gl_Position value, which must be a vec4() type.
With legacy OpenGL (which we are using here), the gl_Position
is generally calculated by using the built-in variable "gl_Vertex",
which is a vec4() which represents the vertex generated by 
the fixed-function rendering pipeline.</div>
	<div class="paragraph">Most OpenGL programs tend to use a perspective projection 
matrix to transform the model-space coordinates of a cartesian 
model into the "view coordinate" space of the screen.  Legacy
OpenGL included functions which would manipulate these matrices
via "translation", "rotation", "scaling" and the like.  Modern 
OpenGL programmers are expected the calculate the matrices 
themselves (or have a library that does it for them).</div>
	<div class="paragraph">Here we are just going to use OpenGLContext's built-in matrix
calculation which will set up the "model-view matrix" for us 
as a simple perspective transformation.</div>
	<div class="paragraph">The final vertex position in view coordinates is calculated 
with a simple dot-product of the model-view matrix and the
vertex to be transformed.  The main() function is defined using 
the C-like GLSL syntax to return nothing (void).  Each of the 
variables used here is a (built-in) global, so we don't have 
to declare their data-types.
</div>
</div>
	<div class="code-sample">		VERTEX_SHADER = compileShader("""
		void main() {
			gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
		}""", GL_VERTEX_SHADER)
</div>
	<div class="commentary">
	<div class="paragraph">After a vertex is processed by the vertex shader, it passes 
		through a number of fixed-function processes, including the 
		"clipping" process, which may turn a single vertex into multiple
		vertices in order to only render geometry "ahead" of the near 
		clipping plane.</div>
	<div class="paragraph">Thus if a triangle is "poking into your eye" the GL will
generate two vertices that are at the points where the 
triangle intersects the near clipping plane and create 3
triangles from the original one triangle (the same is true of 
all of the clipping plans for the frustum).</div>
	<div class="paragraph">The fixed-function operations will generate "fragments", which 
can be loosely thought of as a "possible pixel". They may 
represent a sub-sampling interpolation value, or a value that 
will eventually be hidden behind another pixel (overdrawn).</div>
	<div class="paragraph">Our renderer will be given a (large number of) fragments each 
of which will have a position calculated based on the area 
of the triangle vertices (gl_Position values) that our vertex 
shader generated.</div>
	<div class="paragraph">The fragment shader only *needs* to do one thing, which is to 
generate a gl_FragColor value, that is, to determine what colour 
the fragment should be.  The shader can also decide to write 
different colours to different colour buffers, or even change 
the position of the fragment, but its primary job is simply 
to determine the colour of the pixel (a vec4() value).</div>
	<div class="paragraph">In our code here, we create a new colour for each pixel, which 
is a pure green opaque (the last 1) value.  We assign the value 
to the (global, built-in) gl_FragColor value and we are finished.
</div>
</div>
	<div class="code-sample">		FRAGMENT_SHADER = compileShader("""
		void main() {
			gl_FragColor = vec4( 0, 1, 0, 1 );
		}""", GL_FRAGMENT_SHADER)
</div>
	<div class="commentary">
	<div class="paragraph">Now that we have defined our shaders, we need to compile them 
		into a program on our video card which can be applied to geometry.
		The compileProgram convenience function does these operations:</div>
	<ul class="">
	<li class="">creates a shader "program" (glCreateProgram)</li>
	<li class="">for each of the vertex and fragment shader, if provided	* compiles the shader (glCreateShader, glShaderSource,glCompileShader)	* attaches the shader to the program </li>
	<li class="">links the program (glLinkProgram)</li>
	<li class="">validates the program (glValidateProgram,glGetProgramiv)</li>
	<li class="">cleans up and returns the shader program</li>
</ul>
	<div class="paragraph">The shader program is an opaque GLuint that is used to refer 
to the shader when speaking to the GL.  With this, we have 
created an OpenGL shader, now we just need to give it something 
to render.
</div>
</div>
	<div class="code-sample">		self.shader = compileProgram(VERTEX_SHADER,FRAGMENT_SHADER)
</div>
	<div class="commentary">
	<div class="paragraph">Modern OpenGL wants you to load your data onto your video 
		card as much as possible.  For geometric data, this is generally 
		done via a Vertex Buffer Object.  These are flexible data-storage
		areas reserved on the card, with various strategies available
		for streaming data in/out.</div>
	<div class="paragraph">For our purposes we can think of the VBO as a place on the card
to which we are going to copy our vertex-description data.  We'll
use a Numpy array to define this data, as it's a convenient format
for dealing with large arrays of numeric values.</div>
	<div class="paragraph">Modern cards work best with a format where all of the data
associated with a single vertex is "tightly packed" into a VBO,
so each record in the array here represents all of the data 
needed to render a single vertex.  Since our shader only needs 
the vertex coordinate to do its rendering, we'll use 3
floating-point values.  (Note: not doubles, as in a Python
float, but 3 machine floating point values).</div>
	<div class="paragraph">Modern OpenGL only supports triangle and point-type geometry,
so the simplest form of drawing (though not necessarily the 
fastest) is to specify each vertex of a set of triangles in 
order.  Here we create one triangle and what looks like a 
square to the viewer (two triangles with two shared vertices).</div>
	<div class="paragraph">The vbo.VBO class simply takes an array-compatible format and 
stores the value to be pushed to the card later.  It also takes 
various flags to control the more advanced features, but we'll 
look at those later.
</div>
</div>
	<div class="code-sample">		self.vbo = vbo.VBO(
			array( [
				[  0, 1, 0 ],
				[ -1,-1, 0 ],
				[  1,-1, 0 ],
				[  2,-1, 0 ],
				[  4,-1, 0 ],
				[  4, 1, 0 ],
				[  2,-1, 0 ],
				[  4, 1, 0 ],
				[  2, 1, 0 ],
			],'f')
		)
</div>
	<div class="commentary">
	<div class="paragraph">We've now completed our application initialization, we 
		have our shaders compiled and our VBO ready-to-render.  Now 
		we need to actually tell OpenGLContext how to render our scene.
		The Render() method of the context is called after all of the 
		boilerplate OpenGL setup has been completed and the scene 
		should be rendered in model-space.  OpenGLContext has created 
		a default Model-View matrix for a perspective scene where the 
		camera is sitting 10 units from the origin.  It has cleared the 
		screen to white and is ready to accept rendering commands.
</div>
</div>
	<div class="code-sample">	def Render( self, mode):
		"""Render the geometry for the scene."""
</div>
	<div class="commentary">
	<div class="paragraph">We tell OpenGL to use our compiled shader, this is 
		a simple GLuint that is an opaque token that describes the shader 
		for OpenGL.  Until we Use the shader, the GL is using the 
		fixed-function (legacy) rendering pipeline.
</div>
</div>
	<div class="code-sample">		glUseProgram(self.shader)
</div>
	<div class="commentary">
	<div class="paragraph">Now we tell OpenGL that we want to enable our VBO as the 
		source for geometric data.  There are two VBO types that can 
		be active at any given time, a geometric data buffer and an 
		index buffer, the default here is the geometric buffer.
</div>
</div>
	<div class="code-sample">		try:
			self.vbo.bind()
			try:
</div>
	<div class="commentary">
	<div class="paragraph">Here we tell OpenGL to process vertex (location) data 
				from our vertex pointer (here we pass the VBO).  The VBO 
				acts just like regular array data, save that it is stored 
				on the card, rather than in main memory.  The VBO object 
				is actually passing in a void pointer (None) for the array 
				pointer, as the start of the enabled VBO is taken as 
				the 0 address for the arrays.</div>
	<div class="paragraph">Note the use here of the "typed" glVertexPointerf function,
while this is a convenient form for this particular
tutorial, most VBO-based rendering will use the standard 
form which includes specifying offsets, data-types,
strides, and the like for interpreting the array.  We 
will see the more involved form in the next tutorial.
</div>
</div>
	<div class="code-sample">				glEnableClientState(GL_VERTEX_ARRAY);
				glVertexPointerf( self.vbo )
</div>
	<div class="commentary">
	<div class="paragraph">Finally we actually tell OpenGL to draw some geometry.
				Here we tell OpenGL to draw triangles using vertices, 
				starting with the offset 0 and continuing for 9 vertices
				(that is, three triangles).  glDrawArrays always draws 
				"in sequence" from the vertex array.  We'll look at using 
				indexed drawing functions later.
</div>
</div>
	<div class="code-sample">				glDrawArrays(GL_TRIANGLES, 0, 9)
</div>
	<div class="commentary">
	<div class="paragraph">Having completed rendering our geometry, we clean up 
				the OpenGL environment.  We unbind our vbo, so that any 
				traditional non-VBO-using code can operate, and unbind 
				our shader so that geometry that uses the fixed-function 
				(legacy) rendering behaviour will work properly.
</div>
</div>
	<div class="code-sample">			finally:
				self.vbo.unbind()
				glDisableClientState(GL_VERTEX_ARRAY);
		finally:
			glUseProgram( 0 )
</div>
	<div class="commentary">
	<div class="paragraph">We need to actually run the code when operating as a top-level 
script.  The TestingContext import above also gave us an appropriate
mainloop function to call.</div>
</div>
	<div class="code-sample">
if __name__ == "__main__":
	MainFunction ( TestContext)
</div>
	<div class="commentary">
	<div class="paragraph">
When run from the command-line, we should see a triangle and a 
rectangle in solid green floating over a white background, as seen
in our screenshot above.</div>
	<div class="paragraph">Terms:</div>
	<div class="paragraph">frustum -- the viewing "stage" of your world, i.e. the part 
	of the world which is visible to the "camera", includes 
	a near and far clipping plane, as well as clipping planes 
	for the left, right, top and bottom</div>
	<div class="paragraph">GLSL -- the OpenGL Shading Language, there are two levels 
	of shading language defined within OpenGL, the earlier of 
	the two is a low-level assembly-like language.  The later,
	GLSL is a slightly higher-level C-like language, this is 
	the language we will be using in these tutorials.  There 
	are also third-party languages, such as Cg, which can 
	compile the same source-code down to e.g. 
	DirectX and/or OpenGL renderers.</div>
	<div class="paragraph">legacy -- OpenGL is an old standard, the traditional API has 
	been largely deprecated by the OpenGL standards board, the 
	vendors generally support the old APIs, but their use is 
	officially discouraged.  The Legacy APIs had a single 
	rendering model which was customized via a large number of 
	global state values.  The new APIs are considerably more 
	flexible, but require somewhat more effort to use.
</div>
</div>
<table width="100%"><thead>
	<tr>
		<td width="8em;"></td><th align="center"><a href="index.html">OpenGLContext Python tutorials</a></th><td width="8em;"></td>
	</tr>
	<tr>
	<td><a href="index.html">Index</a></td>
	<td align="center">Shader-based Rendering: First steps</td>
	<td align="right"><a href="shader_2.xhtml">Next</a></td>
	</tr>
</thead></table>
<div class="metadata">This document was generated by <code>bzr branch http://bazaar.launchpad.net/%7Emcfletch/pyopengl/directdocs/</code> on 2009-07-20T01:44:34.595400 from shader_1.py</div>
</body>
</html>